<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[hdu1271]整数对]]></title>
    <url>%2F2019%2F02%2F17%2F%5Bhdu1271%5D%E6%95%B4%E6%95%B0%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：Gardon和小希玩了一个游戏，Gardon随便想了一个数A（首位不能为0），把它去掉一个数字以后得到另外一个数B，他把A和B的和N告诉了小希，让小希猜想他原来想的数字。不过为了公平起见，如果小希回答的数虽然不是A，但同样能达到那个条件（去掉其中的一个数字得到B，A和B之和是N），一样算小希胜利。而且小希如果能答出多个符合条件的数字，就可以得到额外的糖果。所以现在小希希望你编写一个程序，来帮助她找到尽可能多的解。例如，Gardon想的是A=31,B=3 告诉小希N=34，小希除了回答31以外还可以回答27（27+7=34）所以小希可以因此而得到一个额外的糖果。 输入描述：输入包含多组数据，每组数据一行，包含一个数N(1&lt;=N&lt;=10^9)，文件以0结尾。输出描述：对于每个输入的N，输出所有符合要求的解（按照大小顺序排列）如果没有这样的解，输出”No solution.” 输入样例：34152210 输出样例：27 31 32126 136 139 141No solution. 解析：一看到题目没有一点想法，结果对着题目瞪了大半天…&emsp;&emsp;&emsp;听了老师讲解后便恍然大悟，原来还有这么巧妙的做法。&emsp;&emsp;&emsp;设原来的数为abc，b是删除的那个数，a是删去的数之前的所有数，c是删去的数之后的所有数。&emsp;&emsp;&emsp;比如原来的数是1341，若要删去4，则a=13，b=4，c=1。&emsp;&emsp;&emsp;于是我们可以枚举b所在的数位，假设b所在k位，那么&emsp;&emsp;&emsp;原数=$a\times10^{k+1}+b*10^{k}+c$&emsp;&emsp;&emsp;删去后=$a\times10^{k}+c$&emsp;&emsp;&emsp;两数相加，即n=$(11a+b)\times10^{k}+2c$&emsp;&emsp;&emsp;如此一来就可算出a、b、c的值。&emsp;&emsp;&emsp;这里注意a与b不能两个都为0，且要注意2c的进位问题。&emsp;&emsp;&emsp;其实进位只要关心b-1后是否会小于0即可。&emsp;&emsp;&emsp;于是我们高高兴兴地打完了代码，提交后却发现，WA了。&emsp;&emsp;&emsp;为什么呢？看看其他各位大佬的代码，原来这么计算下来会出现重复，比如5002在计算时会将十位与百位上的0各自去掉，所以要判重。 代码如下：12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n, tot, ans[10001];int a, b, c;int main() &#123; while (scanf("%d", &amp;n), n &gt; 0) &#123; tot = 0; for (int k = 1; k &lt;= n; k *= 10) &#123; a = n / k / 11; b = n / k % 11; if ((a + b) != 0 &amp;&amp; b &lt; 10) &#123; //不进位 c = (n - b * k - a * k * 11) / 2; if (n == a * k * 11 + b * k + c * 2) ans[++ tot] = a * 10 * k + b * k + c; &#125; b --; if ((a + b) != 0 &amp;&amp; b &gt;= 0) &#123; //进位 c = (n - b * k - a * k * 11) / 2; if (n == a * k * 11 + b * k + c * 2) ans[++ tot] = a * 10 * k + b * k + c; &#125; &#125; sort(ans + 1, ans + 1 + tot); tot = unique(ans + 1, ans + 1 + tot) - ans - 1; if (!tot) printf("No solution."); else for (int i = 1; i &lt;= tot; ++ i) &#123; printf("%d", ans[i]); //不要问我为什么那么麻烦，不然会PE if (i &lt; tot) putchar(' '); &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>hdu</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hdu4334]Trouble]]></title>
    <url>%2F2019%2F02%2F17%2F%5Bhdu4334%5DTrouble%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：给定5个集合，从每个集合中选一个数，使得5个数的和为0. 输入格式：第一行：一个整数t表示数据组数。接下来t组数据，每组数据第一行一个整数表示集合的大小。接下来5行，每行n个数表示集合中的i元素。 输出格式：对于每组数据，输出Yes或No表示是否可以使数的和为0. 输入样例：221 -11 -11 -11 -11 -131 2 3-1 -2 -34 5 6-1 3 2-4 -10 -1 输出样例：NoYes 解析：一看到题目，n^5进行枚举肯定不可取。&emsp;&emsp;&emsp;那么先n^2预处理前2个集合数的和，经行hash，后n^3枚举后三行，在hash表中查。&emsp;&emsp;&emsp;似乎可行，于是便开打。&emsp;&emsp;&emsp;一提交，TLE了。&emsp;&emsp;&emsp;进行一波卡常，还是TLE了。&emsp;&emsp;&emsp;那么这么做不可行吗？可行！网上也有许多大佬用这方法A了此题。可能是本蒟蒻太弱，常数太大…&emsp;&emsp;&emsp;这里介绍用two pointers做的做法。&emsp;&emsp;&emsp;首先把前两个集合中的数两两相加，再将第3与4个集合中的数两两相加，得到两个数组。&emsp;&emsp;&emsp;将两个数组都从小到大sort一次。&emsp;&emsp;&emsp;枚举第5个集合中的数，对于集合中的每个数，创建l，r两个指针，分别指向两个数组其中一个的头与另一个的尾。&emsp;&emsp;&emsp;若三个数相加&gt;0，则将尾的指针向左移一位。&emsp;&emsp;&emsp;若&lt;0，则将头的指针向右移一位。&emsp;&emsp;&emsp;若=0则输出Yes，直接退出。&emsp;&emsp;&emsp;若不能得出0，则输出No。&emsp;&emsp;&emsp;一个比较巧妙的做法，无法理解的话可以画个图自行理解理解。&emsp;&emsp;&emsp;时间复杂度O(n^3)。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define ll long long#define rint register int using namespace std;const int maxn = 205;int t, n, tot;ll a[6][maxn], b[maxn * maxn], c[maxn * maxn];ll read(void) &#123; char c; while (c = getchar(), (c &lt; '0' || c &gt; '9') &amp;&amp; c != '-'); ll x = 0, y = 1; if (c == '-') y = -1; else x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x * y; &#125;int main() &#123; t = read(); rint i, j; while (t --) &#123; n = read(); for (i = 1; i &lt;= 5; ++ i) for (j = 1; j &lt;= n; ++ j) a[i][j] = read(); tot = 0; for (i = 1; i &lt;= n; ++ i) //构建第一个数组 for (j = 1; j &lt;= n; ++ j) b[++ tot] = a[1][i] + a[2][j]; tot = 0; for (i = 1; i &lt;= n; ++ i) //构建第二个数组 for (j = 1; j &lt;= n; ++ j) c[++ tot] = a[3][i] + a[4][j]; sort(b + 1, b + 1 + n * n); //排序 sort(c + 1, c + 1 + n * n); int flag = 0; for (i = 1; i &lt;= n; ++ i) &#123; int l = 1, r = n * n; if (flag) break; for (j = 1; j &lt;= n * n * 2; ++ j) &#123; //一共要进行n*n*2次移动 ll val = a[5][i] + b[l] + c[r]; if (val == 0) &#123; flag = 1; break; &#125; else if (val &gt; 0) r --; else l ++; &#125; &#125; if (flag) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>hdu</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于本博客]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我又滚回来写博客了，虽说之前也写过一些，但好像大多都被我用来存代码了，真正认真写的数量不多。可现在搭好了自己的博客，便也不会那么随便了。说到搭博客，这也花了我好几个小时的时间，一大堆的东西以及不断的报错，搞的我心态爆炸（不过好在坚持过来了QAQ）。 关于之前写的博客，我会将上面比较有用的转移过来。而之前写博客的网站，随缘更新吧~ 不管怎样，写博客也是为了记录下自己学习中的经验与知识，以及将自己的博客向他人装装逼自己的学习经历与别人一起分享。在接下来的博客创作中，我会将自己解题时的所思所想一同写下，记录下自己的解题思路，好让内容利于理解。在总结算法或数据结构时，我也会将自己的思考写进博客中，与大家一同分享。同时也是为了让别人可以更加深刻地理解一个知识点。 总之，希望我的博客可以帮助到更多的人。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
</search>
