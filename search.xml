<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[hdu4334]Trouble]]></title>
    <url>%2F2019%2F02%2F17%2F%5Bhdu4334%5DTrouble%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：给定5个集合，从每个集合中选一个数，使得5个数的和为0. 输入格式：第一行：一个整数t表示数据组数。接下来t组数据，每组数据第一行一个整数表示集合的大小。接下来5行，每行n个数表示集合中的i元素。 输出格式：对于每组数据，输出Yes或No表示是否可以使数的和为0. 输入样例：221 -11 -11 -11 -11 -131 2 3-1 -2 -34 5 6-1 3 2-4 -10 -1 输出样例：NoYes 解析：一看到题目，n^5进行枚举肯定不可取。&emsp;&emsp;&emsp;那么先n^2预处理前2个集合数的和，经行hash，后n^3枚举后三行，在hash表中查。&emsp;&emsp;&emsp;似乎可行，于是便开打。&emsp;&emsp;&emsp;一提交，TLE了。&emsp;&emsp;&emsp;进行一波卡常，还是TLE了。&emsp;&emsp;&emsp;那么这么做不可行吗？可行！网上也有许多大佬用这方法A了此题。可能是本蒟蒻太弱，常数太大…&emsp;&emsp;&emsp;这里介绍用two pointers做的做法。&emsp;&emsp;&emsp;首先把前两个集合中的数两两相加，再将第3与4个集合中的数两两相加，得到两个数组。&emsp;&emsp;&emsp;将两个数组都从小到大sort一次。&emsp;&emsp;&emsp;枚举第5个集合中的数，对于集合中的每个数，创建l，r两个指针，分别指向两个数组其中一个的头与另一个的尾。&emsp;&emsp;&emsp;若三个数相加&gt;0，则将尾的指针向左移一位。&emsp;&emsp;&emsp;若&lt;0，则将头的指针向右移一位。&emsp;&emsp;&emsp;若=0则输出Yes，直接退出。&emsp;&emsp;&emsp;若不能得出0，则输出No。&emsp;&emsp;&emsp;一个比较巧妙的做法，无法理解的话可以画个图自行理解理解。&emsp;&emsp;&emsp;时间复杂度O(n^3)。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define ll long long#define rint register int using namespace std;const int maxn = 205;int t, n, tot;ll a[6][maxn], b[maxn * maxn], c[maxn * maxn];ll read(void) &#123; char c; while (c = getchar(), (c &lt; '0' || c &gt; '9') &amp;&amp; c != '-'); ll x = 0, y = 1; if (c == '-') y = -1; else x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x * y; &#125;int main() &#123; t = read(); rint i, j; while (t --) &#123; n = read(); for (i = 1; i &lt;= 5; ++ i) for (j = 1; j &lt;= n; ++ j) a[i][j] = read(); tot = 0; for (i = 1; i &lt;= n; ++ i) //构建第一个数组 for (j = 1; j &lt;= n; ++ j) b[++ tot] = a[1][i] + a[2][j]; tot = 0; for (i = 1; i &lt;= n; ++ i) //构建第二个数组 for (j = 1; j &lt;= n; ++ j) c[++ tot] = a[3][i] + a[4][j]; sort(b + 1, b + 1 + n * n); //排序 sort(c + 1, c + 1 + n * n); int flag = 0; for (i = 1; i &lt;= n; ++ i) &#123; int l = 1, r = n * n; if (flag) break; for (j = 1; j &lt;= n * n * 2; ++ j) &#123; //一共要进行n*n*2次移动 ll val = a[5][i] + b[l] + c[r]; if (val == 0) &#123; flag = 1; break; &#125; else if (val &gt; 0) r --; else l ++; &#125; &#125; if (flag) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>two pointers</tag>
        <tag>思维</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于本博客]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我又滚回来写博客了，虽说之前也写过一些，但好像大多都被我用来存代码了，真正认真写的数量不多。可现在搭好了自己的博客，便也不会那么随便了。说到搭博客，这也花了我好几个小时的时间，一大堆的东西以及不断的报错，搞的我心态爆炸（不过好在坚持过来了QAQ）。 关于之前写的博客，我会将上面比较有用的转移过来。而之前写博客的网站，随缘更新吧~ 不管怎样，写博客也是为了记录下自己学习中的经验与知识，以及将自己的博客向他人装装逼自己的学习经历与别人一起分享。在接下来的博客创作中，我会将自己解题时的所思所想一同写下，记录下自己的解题思路，好让内容利于理解。在总结算法或数据结构时，我也会将自己的思考写进博客中，与大家一同分享。同时也是为了让别人可以更加深刻地理解一个知识点。 总之，希望我的博客可以帮助到更多的人。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
</search>
