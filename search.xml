<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[bzoj1042]硬币购物]]></title>
    <url>%2F2019%2F04%2F05%2F%5Bbzoj1042%5D%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：硬币购物一共有4种硬币。面值分别为c1,c2,c3,c4。某人去商店买东西，去了tot次。每次带di枚ci硬币，买si的价值的东西。请问每次有多少种付款方法。 输入格式：第一行 c1,c2,c3,c4,tot 下面tot行 d1,d2,d3,d4,s,其中di,s&lt;=100000,tot&lt;=1000。 输出格式：每次的方法数。输入样例：1 2 5 10 23 2 3 1 101000 2 2 2 900 输出格式：427 解析：比较基础的容斥题。&emsp;&emsp;&emsp;看到题目后就想到了背包，但数据范围不允许。&emsp;&emsp;&emsp;那么令dp[i]表示不考虑数量限制的情况下所能取的方案数。&emsp;&emsp;&emsp;这就是个完全背包，预处理出$dp_{1…100000}$。&emsp;&emsp;&emsp;那么对于每次询问的s，答案就是dp[s]-有一个超过限制的+有两个超过限制的-有三个超过限制的+有四个超过限制的。&emsp;&emsp;&emsp;可如何计算每一种超过限制的方案数呢？&emsp;&emsp;&emsp;以超过第1种的限制为例。若第一种取的个数超过d[1]，即至少为d[1]+1时，就超过了限制。&emsp;&emsp;&emsp;所以第一种超过限制的方案数即为dp[s-(d[1]+1)*c[1]]。&emsp;&emsp;&emsp;由于只有16种情况，所以计算时直接枚举即可。 代码如下：12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#define ll long longusing namespace std;int c[10], d[10], q, s;ll dp[100005], ans; int read(void) &#123; char c; while (c = getchar(), c &lt; '0' || c &gt;'9'); int x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x;&#125;ll solve(int x) &#123; int sign = 1; ll tot = s; for (int i = 0; i &lt; 4; ++ i) //确定符号，即是+还是- if ((1 &lt;&lt; i) &amp; x) sign = -sign; for (int i = 0; i &lt; 4; ++ i) if ((1 &lt;&lt; i) &amp; x) tot -= (d[i + 1] + 1) * c[i + 1]; if (tot &lt; 0) return 0; //若小于0，即不存在，直接返回0 return dp[tot] * sign;&#125;int main() &#123; for (int i = 1; i &lt;= 4; ++ i) c[i] = read(); dp[0] = 1; for (int i = 1; i &lt;= 4; ++ i) //完全背包 for (int j = c[i]; j &lt;= 100000; ++ j) dp[j] += dp[j - c[i]]; q = read(); while (q --) &#123; for (int i = 1; i &lt;= 4; ++ i) d[i] = read(); s = read(); ans = 0; for (int i = 0; i &lt; 16; ++ i) ans += solve(i); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>bzoj</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1141F]Same Sum Blocks]]></title>
    <url>%2F2019%2F03%2F30%2F%5BCF1141F%5DSame%20Sum%20Blocks%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：给定一个长度为n的数列，从中选出互不相交的几段，使每段的和相等，求最多的段数。 输入格式：第一行，一个数n，表示数列的长度。第二行，n个数，表示数列中的数。 输出格式：第一行，一个数k，k表示最多的段数。接下来k行，每行两个整数，表示每段的开头与结尾。若有多组答案，输出一组即可。输入样例：11-5 -4 -3 -2 -1 0 1 2 3 4 5 输出样例：23 41 1 解析：F1和F2都差不多，只不过F1可以用比较暴力的做法直接做，这里就直接介绍F2的做法。算法理解起来也不难。&emsp;&emsp;&emsp;先预处理出和为x的一段数的左右坐标，后按右端点的顺序排序。&emsp;&emsp;&emsp;再枚举所有的和。因为已按右端点排了序，所以直接贪心取即可。&emsp;&emsp;&emsp;处理时可以用map，vector，pair进行。&emsp;&emsp;&emsp;细节看代码。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;#define int long long#define fir first#define sec second#define pa pair &lt;int, int&gt;#define mp make_pairusing namespace std;const int maxn = 1505;int n, a[maxn], tot, ansx[maxn], ansy[maxn], res, s[maxn], mark, num[maxn * maxn];map &lt;int, int&gt; ma;vector &lt;pa&gt; ve[maxn * maxn];int read(void) &#123; char c; while (c = getchar(), (c &lt; '0' || c &gt; '9') &amp;&amp; c != '-'); int x = 0, y = 1; if (c == '-') y = -1; else x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x * y; &#125;signed main() &#123; n = read(); for (int i = 1; i &lt;= n; ++ i) a[i] = read(), s[i] = s[i - 1] + a[i]; for (int r = 1; r &lt;= n; ++ r) &#123; //处理和的同时按右端点排序 int sum = 0; for (int l = r; l ; -- l) &#123; sum += a[l]; if (!ma[sum]) ma[sum] = ++ mark, num[mark] = sum; ve[ma[sum]].push_back(mp(l, r)); &#125; &#125; for (int i = 1; i &lt;= mark; ++ i) &#123; //枚举所有的和 int x = num[i]; int now = 0, tmp = 0, bj = ma[x]; for (int k = 0; k &lt; ve[bj].size(); ++ k) &#123; pa u = ve[bj][k]; if (u.fir &lt;= now) continue; tmp ++; now = u.sec; &#125; if (tmp &gt; tot) &#123; //记录最大值 tot = tmp; tot = tmp; res = x; &#125; &#125; res = ma[res]; for (int i = 0, now = 0, tmp = 0; i &lt; ve[res].size(); ++ i) &#123; //获得答案 pa u = ve[res][i]; if (u.fir &lt;= now) continue; ansx[++ tmp] = u.fir; ansy[tmp] = u.sec; now = u.sec; &#125; printf("%I64d\n", tot); for (int i = 1; i &lt;= tot; ++ i) printf("%I64d %I64d\n", ansx[i], ansy[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CF</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1132C]Painting the Fence]]></title>
    <url>%2F2019%2F03%2F09%2F%5BCF1132C%5DPainting%20the%20Fence%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：给定一条长度为n的线段以及另外q条线段。从q条线段中选出q-2条，使得覆盖线段的长度最长。 输入格式:第一行，两个数n和q。接下来q行，每行两个整数，表示每条线段的起始点和终止点。 输出格式：输出一个数字，表示覆盖的最长长度。 输入样例：7 51 44 55 66 73 5 输出样例：7 解析：题目不难。&emsp;&emsp;&emsp;从q中选出q-2个，即从q中选出2个不选。&emsp;&emsp;&emsp;所以可以枚举那两个进行计算。&emsp;&emsp;&emsp;可以在q段每一段所覆盖的位置+1。&emsp;&emsp;&emsp;先枚举一个不选，而删去这段后若为1则可以被再次删去。&emsp;&emsp;&emsp;对于1的个数可以用前缀和维护。 代码如下：12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 5005;int n, q, x[maxn], y[maxn], res[maxn], tmp[maxn], s, ans, sum[maxn];int read(void) &#123; char c; while (c = getchar(), c &lt; '0' || c &gt; '9'); int x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x;&#125;int main() &#123; n = read(); q = read(); for (int i = 1; i &lt;= q; ++ i) &#123; x[i] = read(); y[i] = read(); for (int j = x[i]; j &lt;= y[i]; ++ j) res[j] ++; &#125; for (int i = 1; i &lt;= n; ++ i) if (res[i]) s ++; //统计覆盖总数 for (int i = 1; i &lt;= q; ++ i) &#123; int val = s; for (int j = 1; j &lt;= n; ++ j) tmp[j] = res[j]; //复制数组，防止对原数组进行修改 for (int j = x[i]; j &lt;= y[i]; ++ j) &#123; //删去所覆盖的 tmp[j] --; if (!tmp[j]) val --; &#125; for (int j = 1; j &lt;= n; ++ j) sum[j] = sum[j - 1] + (tmp[j] == 1); for (int j = i + 1; j &lt;= q; ++ j) &#123; //维护答案 ans = max(ans, val - sum[y[j]] + sum[x[j] - 1]); &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CF</tag>
        <tag>枚举</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj1050]旅行comf]]></title>
    <url>%2F2019%2F03%2F03%2F%5Bbzoj1050%5D%E6%97%85%E8%A1%8Ccomf%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：给你一个无向图，N(N&lt;=500)个顶点, M(M&lt;=5000)条边，每条边有一个权值Vi(Vi&lt;30000)。给你两个顶点S和T，求一条路径，使得路径上最大边和最小边的比值最小。如果S和T之间没有路径，输出”IMPOSSIBLE”，否则输出这个比值，如果需要，表示成一个既约分数。 备注： 两个顶点之间可能有多条路径。 输入描述：第一行包含两个正整数，N和M。下来的M行每行包含三个正整数：x，y和v。表示景点x到景点y之间有一条双向公路，车辆必须以速度v在该公路上行驶。最后一行包含两个正整数s，t，表示想知道从景点s到景点t最大最小速度比最小的路径。s和t不可能相同。输出描述如果景点s到景点t没有路径，输出“IMPOSSIBLE”。否则输出一个数，表示最小的速度比。如果需要，输出一个既约分数。 样例输入：3 31 2 101 2 52 3 81 3 样例输出：5/4 解析：提议清楚，题目简单。&emsp;&emsp;&emsp;首先将所有的路径从小到大sort一次。&emsp;&emsp;&emsp;再枚举所有路径中路径长度最长边，从该点往前找到一个可以使s与t连通的点。&emsp;&emsp;&emsp;最后比较答案输出即可。&emsp;&emsp;&emsp;似乎将得有点不清楚，具体的可以看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 505;const int maxm = 5005;int n, m, fa[maxn], ansx, ansy, s, t;struct node&#123; int x, y, v;&#125;a[maxm];int read(void) &#123; char c; while (c = getchar(), c &lt; '0' || c &gt;'9'); int x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x;&#125;int cmp(node a, node b) &#123; return a.v &lt; b.v;&#125;int getf(int x) &#123; if (fa[x] == x) return fa[x]; else return fa[x] = getf(fa[x]);&#125;int gcd(int x, int y) &#123; if (!y) return x; else return gcd(y, x % y);&#125;void sau(int x, int y) &#123; //更新答案 int g = gcd(x, y); x /= g; y /= g; if ((double)x / y &lt; (double)ansx / ansy) ansx = x, ansy = y;&#125;int main() &#123; n = read(); m = read(); ansx = 2e9; ansy = 1; for (int i = 1; i &lt;= m; ++ i) &#123; a[i].x = read(); a[i].y = read(); a[i].v = read(); &#125; s = read(); t = read(); sort(a + 1, a + 1 + m, cmp); for (int i = 1; i &lt;= m; ++ i) &#123; //枚举最大的点 for (int j = 1; j &lt;= n; ++ j) fa[j] = j; fa[a[i].x] = a[i].y; if (getf(s) == getf(t)) return printf("1"), 0; int maxv = a[i].v, minv = a[i].v; for (int j = i - 1; j ; -- j) &#123; if (getf(a[j].x) != getf(a[j].y)) fa[getf(a[j].x)] = getf(a[j].y); minv = a[j].v; if (getf(s) == getf(t)) break; &#125; if (getf(s) != getf(t)) continue; sau(maxv, minv); &#125; if (ansx == 2e9 &amp;&amp; ansy == 1) printf("IMPOSSIBLE"); else if (ansy == 1) printf("%d", ansx); else printf("%d/%d", ansx, ansy); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>bzoj</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1131D]Gourmet choice]]></title>
    <url>%2F2019%2F03%2F03%2F%5BCF1131D%5DGourmet%20choice%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：一共有n+m个数，给定这n+m个数的大小关系，求满足条件的每个数的最小值。 输入格式：第一行n和m，表示两组的数的个数。第2~ n+1行，每行m个整数，表示第一组第i个数与第二组第j个数的大小关系。 输出格式：第一行，若无法满足，输出”No”，否则输出”Yes”。第二行，输出第一组的数。第三行，输出第二组的数。 输入样例：3 3&gt;&gt;&gt;&lt;&lt;&lt;&gt;&gt;&gt; 输出样例：Yes3 1 32 2 2 解析：看到题目有点懵，但仔细看看，好像就是个差分约束系统。&emsp;&emsp;&emsp;但好像会超时。算了，反正不会其他的做法，就死马当活马医吧。&emsp;&emsp;&emsp;打完一交，果然超时了。&emsp;&emsp;&emsp;想了一会后似乎又有了些头绪。&emsp;&emsp;&emsp;首先这题并不像其他的差分约束系统题一样有着过分的约束。&emsp;&emsp;&emsp;唯一的约束只有三个，大于、小于和等于。&emsp;&emsp;&emsp;那么如果将小的数向大的数连一条边，便会得到一个DAG。&emsp;&emsp;&emsp;而对于所有相等的点，所在一起即可。&emsp;&emsp;&emsp;那么怎么进行缩店呢，用并查集即可。&emsp;&emsp;&emsp;最后在DAG上跑一遍DP即可。&emsp;&emsp;&emsp;注意DAG上可能会有重边，这样会导致度数错误，要删去重边。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn = 2005;int n, m, fa[maxn], du[maxn], vis[maxn], dp[maxn];char s[maxn][maxn];queue &lt;int&gt; que;vector &lt;int&gt; ve[maxn];int getf(int x) &#123; if (x == fa[x]) return fa[x]; else return fa[x] = getf(fa[x]);&#125;int bfs(void) &#123; //DP int tot = 0; for (int i = 1; i &lt;= n + m; ++ i) if (!du[i]) que.push(i), tot ++; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = 0; i &lt; ve[u].size(); ++ i) &#123; int v = ve[u][i]; v = getf(v); du[v] --; dp[v] = max(dp[v], dp[u] + 1); if (!du[v]) &#123; que.push(v); tot ++; &#125; &#125; &#125; if (tot &lt; n + m) return 0; return 1;&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++ i) scanf("%s", s[i] + 1); for (int i = 1; i &lt;= n + m; ++ i) fa[i] = i; for (int i = 1; i &lt;= n; ++ i) //预先将等于的缩在一起 for (int j = 1; j &lt;= m; ++ j) if (s[i][j] == '=') fa[getf(i)] = getf(n + j); for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= m; ++ j) &#123; if (s[i][j] == '=') continue; if (getf(i) == getf(n + j)) return printf("No"), 0; //违反条件直接退出 if (s[i][j] == '&lt;') ve[getf(i)].push_back(getf(n + j)); else ve[getf(n + j)].push_back(getf(i)); &#125; for (int i = 1; i &lt;= n + m; ++ i) sort(ve[i].begin(), ve[i].end()); //删去重边 for (int i = 1; i &lt;= n + m; ++ i) ve[i].erase(unique(ve[i].begin(), ve[i].end()), ve[i].end()); for (int i = 1; i &lt;= n + m; ++ i) //统计度数 for (int j = 0; j &lt; ve[i].size(); ++ j) du[ve[i][j]] ++; if (!bfs()) return printf("No"), 0; for (int i = 1; i &lt;= n + m; ++ i) dp[getf(i)] = max(dp[getf(i)], dp[i]); puts("Yes"); for (int i = 1; i &lt;= n; ++ i) printf("%d ", dp[getf(i)] + 1); puts(""); for (int i = n + 1; i &lt;= n + m; ++ i) printf("%d ", dp[getf(i)] + 1); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>CF</tag>
        <tag>并查集</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1118C]Palindromic Matrix]]></title>
    <url>%2F2019%2F03%2F02%2F%5BCF1118C%5DPalindromic%20Matrix%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：给定$n \times n$个数，要求构造一个$n \times n$的矩阵，使得这个矩阵是个回文矩阵。 输入格式：第一行一个数n。第二行$n \times n$个数表示给定的数。 输出格式：输出一个回文矩阵，输出”YES”，并输出一种即可。若无法构成回文矩阵，则输出”NO”。 输入样例：41 8 8 1 2 2 2 2 2 2 2 2 1 8 8 1输出样例：YES1 2 2 18 2 2 88 2 2 81 2 2 1 解析：题目不难？&emsp;&emsp;&emsp;看了看题面，发现若要成为回文的，那么每一个位置填数的个数只能为1或2或4。&emsp;&emsp;&emsp;那么找出每个所需个数相同的位置一起处理，每次看能否填上即可。&emsp;&emsp;&emsp;似乎没有什么好讲的，看到代码就懂了。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;vector&gt;#define pa pair &lt;int, int&gt;#define fir first#define sec second#define mp make_pairusing namespace std;const int maxn = 25;int n, ans[maxn][maxn], bt[1005];vector &lt;pa&gt; ve[5];int read(void) &#123; char c; while (c = getchar(), c &lt; '0' || c &gt; '9'); int x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n * n; ++ i) &#123; int x = read(); bt[x] ++; //记录每个数的个数 &#125; for (int i = 1; i &lt;= (n + 1) &gt;&gt; 1; ++ i) for (int j = 1; j &lt;= (n + 1) &gt;&gt; 1; ++ j) &#123; //统计每种格子的个数 if (i != n - i + 1 &amp;&amp; j != n - j + 1) ve[3].push_back(mp(i, j)); else if ((i != n - i + 1) ^ (j != n - j + 1)) ve[2].push_back(mp(i, j)); else ve[1].push_back(mp(i, j)); &#125; for (int i = 3; i ; -- i) //构造矩阵 for (int j = 0; j &lt; ve[i].size(); ++ j) &#123; int x = ve[i][j].fir, y = ve[i][j].sec; int poi = 1, cur = (i == 3) ? 4 : i; while (poi &lt; 1001 &amp;&amp; bt[poi] &lt; cur) poi ++; if (poi == 1001) return printf("NO"), 0; ans[x][y] = ans[n - x + 1][y] = ans[x][n - y + 1] = ans[n - x + 1][n - y + 1] = poi; bt[poi] -= cur; &#125; puts("YES"); for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= n; ++ j) printf("%d ", ans[i][j]); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI生存手册——splay]]></title>
    <url>%2F2019%2F02%2F19%2FOI%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C%E2%80%94%E2%80%94splay%2F</url>
    <content type="text"><![CDATA[splay是一种非常好用的数据结构，功能十分强大，被称为序列之王。我之前写过一篇关于treap的博客，粗略地介绍了一下treap，如果有空我还会再写一遍（对，如果有空）。splay在操作上比treap更加巧妙，但在理解上似乎稍有难度（其实也不难）。两者都是二叉排序树的升级版，只不过treap是用随机的优先值来维护平衡，splay则是通过旋转来维护。 一、前置知识1234567size[x]:x的子树大小fa[x]:x的父亲节点ch[x][0/1]:x的左儿子和右儿子cnt[x]:权值为x的数出现的次数val[x]:节点标号为x的点的权值rt:树的根tot:树的节点总数 还有一些简单的函数。1234567void up(int x) &#123; //维护节点的size值 size[x] = cnt[x] + size[ch[x][0]] + size[ch[x][1]];&#125;int chk(int x) &#123; //询问该节点是它父亲的左儿子还是右儿子 return ch[fa[x]][1] == x;&#125; 二、旋转操作看下面的一张图。若要将节点4旋转到节点2的位置，图会变成这样：显然，旋转后的树也满足二叉排序树的性质。这样，代码就打出来了：1234567void rotate(int x) &#123; int y = fa[x], z = fa[y], k = chk(x), w = ch[x][k ^ 1]; ch[y][k] = w; fa[w] = y; ch[z][chk(y)] = x; fa[x] = z; ch[x][k ^ 1] = y; fa[y] = x; up(y); up(x);&#125; 如果无法理解可以自己画图比划比划，注意coding过程中不要出现打错或遗漏。如果你掌握了旋转的相关知识，那么恭喜你，splay中最难的部分已经你已经会了。 三、伸展操作说白了就是将一个节点旋转到指定父亲的儿子。不过要注意在祖父，父亲，儿子三点一线时，要先旋父亲，再旋儿子。这么做似乎是为了使树平衡，保持树的深度。1234567891011void splay(int x, int t) &#123; while (fa[x] != t) &#123; int y = fa[x], z = fa[y]; if (z != t) &#123; if (chk(x) == chk(y)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!t) rt = x;&#125; 四、查找操作这是一个辅助操作，可以在后面帮我们解决其他问题。作用便是将最大的小于等于x的数所在的节点splay到根。123456void find(int x) &#123; if (!rt) return; int cur = rt; while (ch[cur][x &gt; val[cur]] &amp;&amp; val[cur] != x) cur = ch[cur][x &gt; val[cur]]; splay(cur, 0);&#125; 五、插入操作将一个数插入树中。从根节点往下找，小于该节点的值就向左儿子走，大于该节点的值就向右儿子走。若值与节点的值相等，就将cnt+1。注意最后要将节点splay到根，以保持树平衡。12345678910111213141516void insert(int x) &#123; int cur = rt, id = 0; while (cur &gt; 0 &amp;&amp; val[cur] != x) &#123; id = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur &gt; 0) cnt[cur] ++; else &#123; cur = ++ tot; if (id) ch[id][x &gt; val[id]] = cur; ch[cur][0] = ch[cur][1] = 0; val[cur] = x; fa[cur] = id; size[cur] = cnt[cur] = 1; &#125; splay(cur, 0);&#125; 六、查询第k大找到树中第k大的数。也是从根节点往下找，由于左节点必定小于右节点，所以可以判断在哪颗子树进行查找。1234567891011int kth(int x) &#123; int cur = rt; while (1) &#123; if (x &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else if (x &gt; size[ch[cur][0]] + cnt[cur]) &#123; x -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else return cur; &#125;&#125; 七、查询排名为x的数这个就比较简单，先调用find，那么排名就是左子树的大小+1。但一般都要先往splay中插入一个-inf来防止爆炸，所以排名便不用+1，即为左子树大小。1234int rank(int x) &#123; find(x); return size[ch[rt][0]];&#125; 八、查找x的前驱先调用一次find，那么要么前驱是根，要么就在左子树最深的右子树。1234567int pre(int x) &#123; find(x); if (x &gt; val[rt]) return rt; int cur = ch[rt][0]; while (ch[cur][1] &gt; 0) cur = ch[cur][1]; return cur;&#125; 九、查找x的后继这也要先调用一次find，但这里要注意，虽然find找到的数是小于等于x的，可如果树上所有的点都大于x，那么find就会失效。所以在找后继时也要判断根是否就是后继。其他的都和找前驱时差不多。1234567int succ(int x) &#123; find(x); if (x &lt; val[rt]) return rt; int cur = ch[rt][1]; while (ch[cur][0] &gt; 0) cur = ch[cur][0]; return cur;&#125; 十、删除值为x的节点这就有点意思了。先将x的前驱splay到根，再将x的后继splay到根的右儿子，那么后继的左儿子就是要删的点。为什么呢？因为一个点有且仅有一个前驱和后继，所以只要确定了前驱与后继，那么这个点就是唯一的。注意如果cnt&gt;1则将cnt-1，且不要忘了将点选到根。123456789void del(int x) &#123; int pr = pre(x), su = succ(x); splay(pr, 0); splay(su, rt); if (cnt[ch[su][0]] &gt; 1) &#123; cnt[ch[su][0]] --; splay(ch[su][0], 0); &#125; else ch[su][0] = 0; &#125; 至此splay所有的基本操作都讲完了，大家可以找一些模板或题目练练手。注意要先插入一个-inf与inf，防止爆炸。模板题代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;using namespace std;const int maxn = 1e5 + 5;int n, size[maxn], ch[maxn][2], val[maxn], cnt[maxn], fa[maxn], rt, tot;int read(void) &#123; char c; while (c = getchar(), (c &lt; '0' || c &gt; '9') &amp;&amp; c != '-'); int x = 0, y = 1; if (c == '-') y = -1; else x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x * y; &#125;void up(int x) &#123; size[x] = cnt[x] + size[ch[x][0]] + size[ch[x][1]];&#125;int chk(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; int y = fa[x], z = fa[y], k = chk(x), w = ch[x][k ^ 1]; ch[y][k] = w; fa[w] = y; ch[z][chk(y)] = x; fa[x] = z; ch[x][k ^ 1] = y; fa[y] = x; up(y); up(x);&#125;void splay(int x, int t) &#123; while (fa[x] != t) &#123; int y = fa[x], z = fa[y]; if (z != t) &#123; if (chk(x) == chk(y)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!t) rt = x;&#125;void find(int x) &#123; if (!rt) return; int cur = rt; while (ch[cur][x &gt; val[cur]] &amp;&amp; val[cur] != x) cur = ch[cur][x &gt; val[cur]]; splay(cur, 0);&#125;void insert(int x) &#123; int cur = rt, id = 0; while (cur &gt; 0 &amp;&amp; val[cur] != x) &#123; id = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur &gt; 0) cnt[cur] ++; else &#123; cur = ++ tot; if (id) ch[id][x &gt; val[id]] = cur; ch[cur][0] = ch[cur][1] = 0; val[cur] = x; fa[cur] = id; size[cur] = cnt[cur] = 1; &#125; splay(cur, 0);&#125;int kth(int x) &#123; int cur = rt; while (1) &#123; if (x &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else if (x &gt; size[ch[cur][0]] + cnt[cur]) &#123; x -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else return cur; &#125;&#125;int rank(int x) &#123; find(x); return size[ch[rt][0]];&#125;int pre(int x) &#123; find(x); if (x &gt; val[rt]) return rt; int cur = ch[rt][0]; while (ch[cur][1] &gt; 0) cur = ch[cur][1]; return cur;&#125;int succ(int x) &#123; find(x); if (x &lt; val[rt]) return rt; int cur = ch[rt][1]; while (ch[cur][0] &gt; 0) cur = ch[cur][0]; return cur;&#125;void del(int x) &#123; int pr = pre(x), su = succ(x); splay(pr, 0); splay(su, rt); if (cnt[ch[su][0]] &gt; 1) &#123; cnt[ch[su][0]] --; splay(ch[su][0], 0); &#125; else ch[su][0] = 0; &#125;int main() &#123; n = read(); insert(2e9); insert(-2e9); while (n --) &#123; int opt = read(), x = read(); if (opt == 1) insert(x); else if (opt == 2) del(x); else if (opt == 3) printf("%d\n", rank(x)); else if (opt == 4) printf("%d\n", val[kth(x + 1)]); else if (opt == 5) printf("%d\n", val[pre(x)]); else if (opt == 6) printf("%d\n", val[succ(x)]); &#125; return 0;&#125; 十一、区间翻转你以为讲完了？其实并没有！splay被称为序列之王的原因便是它可以想线段树一样打标记，以进行区间上的修改。这里就看一道经典的例题：例题首先明确要维护的对象，即序列中每个数的位置（这题中其实就是权值）。而题目中第i个位置的数，可以发现就是树中第k大的数。于是找第i位置上的数就转化成了求第i大的数。于是可以把l-1位置的数旋到根，r+1位置的数旋到根的右儿子，那么右儿子的左子树就是l~r中的数。翻转只要在节点上打上标记，遇上标记时翻转左右子树即可。下放标记和线段树类似，这里就不多说了。注意若翻转起点从1开始，那么-1后就成了0。为了防止0的出现，可以将每个位置的标号都向后移一位，即1位置对应了2，2位置对应了3…，n位置对应了n+1。具体如何实现就是在刚开始时加入一个-inf。最后输出答案时按中序遍历输出即可。注意一下细节就应该没问题。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5 + 5;int n, m, bj[maxn];int size[maxn], cnt[maxn], val[maxn], fa[maxn], ch[maxn][2], rt, tot;int read(void) &#123; char c; while (c = getchar(), c &lt; '0' || c &gt; '9'); int x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x;&#125;void up(int x) &#123; size[x] = cnt[x] + size[ch[x][0]] + size[ch[x][1]];&#125;int chk(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; int y = fa[x], z = fa[y], k = chk(x), w = ch[x][k ^ 1]; ch[x][k ^ 1] = y; ch[y][k] = w; ch[z][chk(y)] = x; fa[y] = x; fa[x] = z; fa[w] = y; up(y); up(x);&#125;void splay(int x, int t) &#123; while (fa[x] != t) &#123; int y = fa[x], z = fa[y]; if (z != t) &#123; if (chk(y) == chk(x)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!t) rt = x;&#125;void insert(int x) &#123; int cur = rt, id = 0; while (cur &gt; 0 &amp;&amp; val[cur] != x) &#123; id = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur &gt; 0) cnt[cur] ++; else &#123; cur = ++ tot; if (id) ch[id][x &gt; val[id]] = cur; val[cur] = x; fa[cur] = id; ch[cur][0] = ch[cur][1] = 0; cnt[cur] = size[cur] = 1; &#125; splay(cur, 0);&#125;void pushdown(int x) &#123; if (!bj[x]) return; swap(ch[x][0], ch[x][1]); bj[ch[x][0]] ^= 1; bj[ch[x][1]] ^= 1; bj[x] = 0;&#125;int kth(int x) &#123; int cur = rt; while (1) &#123; pushdown(cur); //注意这里也要pushdown if (x &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else if (x &gt; size[ch[cur][0]] + cnt[cur]) &#123; x -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else return cur; &#125;&#125;void reverse(int x, int y) &#123; x = kth(x); y = kth(y + 2); //由于向右移了一格，所以x-1变为了x，y+1变为了y+2 splay(x, 0); splay(y, x); bj[ch[y][0]] ^= 1;&#125;void write(int x) &#123; pushdown(x); if (ch[x][0] &gt; 0) write(ch[x][0]); if (val[x] &gt; 0 &amp;&amp; val[x] &lt;= n) printf("%d ", val[x]); if (ch[x][1] &gt; 0) write(ch[x][1]);&#125;int main() &#123; n = read(); m = read(); insert(-2e9); insert(2e9); for (int i = 1; i &lt;= n + 1; ++ i) insert(i); //这里要到n+1 while (m --) &#123; int x = read(), y = read(); reverse(x, y); &#125; write(rt); return 0;&#125; 至此，关于splay的操作就结束了，希望大家可以多多练习，以熟练掌握这一数据结构。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI生存手册</tag>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI生存手册——序言]]></title>
    <url>%2F2019%2F02%2F18%2FOI%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C%E2%80%94%E2%80%94%E5%BA%8F%E8%A8%80%2F</url>
    <content type="text"><![CDATA[为什么要开这么一块呢？其实就是为自己总结算法与数据结构找了一个好听的标题。 此块包含的内容可能会比较杂，各种知识可能都会包括，更新的顺序也不按难度来，各位看看就好。 这些算法中包含了我的理解，如有不对的地方请多多包涵，谢谢。 不管怎样，我会尽我的全力把知识点向大家将清楚，也希望大家能够在我的博客中学到更多的东西。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI生存手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职业体验半日游]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%81%8C%E4%B8%9A%E4%BD%93%E9%AA%8C%E5%8D%8A%E6%97%A5%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[感觉博客好像被我用成了日记… 在寒假的末尾，突然发现自己还有一个职业体验的作业没做，便赶忙联系了我爸的一位同学———某派出所教导员，开始了我的职业体验。 本以为大家都是明白人，盖个章签个字写个评语就好了，可没想到竟是如此正式。没办法，我也只得认命。 上午便跟着一位警察出去处警，本以为是多么好玩，结果就只是处理了些民事纠纷。不过同时我也开拓了自己的视野——原来还有那么奇葩的案子！ 一上来一个神奇的案子：一个人车停在别人家门口，车被别人用粪泼了。 办案时我也在一旁看到了警察的严谨：不被人情干扰，依法办案。 在办案时也有一些比较值得人思考的问题，我这里就不赘述了（主要是因为我太懒了，不想写）。 第二个案子便十分无聊：一个人卖橘子提前谈好了价钱，还收了定金，结果在卖时嫌太便宜，想抬高价格。 说实话，真没想到这么鸡毛蒜皮的小事也要用到警察。到了那后，一屋子挤满了人，七嘴八舌，互相交谈，很是热(吵)闹。屋子中似乎大多都是来看热闹的人，但这也不奇怪，这不就是吃瓜群众吗，谁不是呢？ 互相聊了老半天，终于解决了问题。可是，已经付了定金的事，为什么还要报案呢？ 在派出所吃了午饭，便在办公室和带我的警察闲谈。（不得不说，派出所的伙食确实挺不错）。 在闲谈中，我知道了许多，也明白了许多。我了解了走入社会后的压力，得知了难以对抗的现实，也知道了学习很重要，可似乎又不是最重要的。 “我觉得，人生就是一棵树。如果你主干不断往上长，风一吹就断了。可你如果长出了枝叶，有那么容易被吹断吗？” 不仅仅是人生的哲理，还有许多关于警察这个岗位的事。 是的，从小到大，警察在我们的心中都是那么神圣。警察叔叔这个字眼，下至三岁小孩，上至八十老太都热情地称呼。 可是，殊不知，在警察这个词的背后，隐藏着多少深意。警察换来的，是安全，而这安全，却是由没日没夜的加班加点换来的。 “请问您对自己的工作愿景是什么？” “能够正常上班，正常下班，正常休假，能够有时间陪陪老婆孩子，能够有时间和老婆出去度假。” “这么普通，您就没什么梦想吗？” “梦想？在你这么大的时候还是有的。可现在，我连这普通的想法都没法实现。”原来，这就是警察。警察，真的不好当。办案稍不满意会被投诉，案子没破出来会被投诉，说话不准确会被投诉。这就是警察。“警察也是人，上有老下有小，我也要养家糊口。”“你办案受伤了，你自己没什么关系，你的父母怎么想，他们辛辛苦苦将你带大，为什么当警察就非得受伤？”“警察的工作是围城，里面的人要出去，外面的人要进来。”通过这次的职业体验，我似乎明白了许多，也成长了许多。是啊，人生的路还长，一切都要自己来走。在此感谢教导我的孙皆权警察。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hdu1271]整数对]]></title>
    <url>%2F2019%2F02%2F17%2F%5Bhdu1271%5D%E6%95%B4%E6%95%B0%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：Gardon和小希玩了一个游戏，Gardon随便想了一个数A（首位不能为0），把它去掉一个数字以后得到另外一个数B，他把A和B的和N告诉了小希，让小希猜想他原来想的数字。不过为了公平起见，如果小希回答的数虽然不是A，但同样能达到那个条件（去掉其中的一个数字得到B，A和B之和是N），一样算小希胜利。而且小希如果能答出多个符合条件的数字，就可以得到额外的糖果。所以现在小希希望你编写一个程序，来帮助她找到尽可能多的解。例如，Gardon想的是A=31,B=3 告诉小希N=34，小希除了回答31以外还可以回答27（27+7=34）所以小希可以因此而得到一个额外的糖果。 输入描述：输入包含多组数据，每组数据一行，包含一个数N(1&lt;=N&lt;=10^9)，文件以0结尾。输出描述：对于每个输入的N，输出所有符合要求的解（按照大小顺序排列）如果没有这样的解，输出”No solution.” 输入样例：34152210 输出样例：27 31 32126 136 139 141No solution. 解析：一看到题目没有一点想法，结果对着题目瞪了大半天…&emsp;&emsp;&emsp;听了老师讲解后便恍然大悟，原来还有这么巧妙的做法。&emsp;&emsp;&emsp;设原来的数为abc，b是删除的那个数，a是删去的数之前的所有数，c是删去的数之后的所有数。&emsp;&emsp;&emsp;比如原来的数是1341，若要删去4，则a=13，b=4，c=1。&emsp;&emsp;&emsp;于是我们可以枚举b所在的数位，假设b所在k位，那么&emsp;&emsp;&emsp;原数=$a\times10^{k+1}+b*10^{k}+c$&emsp;&emsp;&emsp;删去后=$a\times10^{k}+c$&emsp;&emsp;&emsp;两数相加，即n=$(11a+b)\times10^{k}+2c$&emsp;&emsp;&emsp;如此一来就可算出a、b、c的值。&emsp;&emsp;&emsp;这里注意a与b不能两个都为0，且要注意2c的进位问题。&emsp;&emsp;&emsp;其实进位只要关心b-1后是否会小于0即可。&emsp;&emsp;&emsp;于是我们高高兴兴地打完了代码，提交后却发现，WA了。&emsp;&emsp;&emsp;为什么呢？看看其他各位大佬的代码，原来这么计算下来会出现重复，比如5002在计算时会将十位与百位上的0各自去掉，所以要判重。 代码如下：12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n, tot, ans[10001];int a, b, c;int main() &#123; while (scanf("%d", &amp;n), n &gt; 0) &#123; tot = 0; for (int k = 1; k &lt;= n; k *= 10) &#123; a = n / k / 11; b = n / k % 11; if ((a + b) != 0 &amp;&amp; b &lt; 10) &#123; //不进位 c = (n - b * k - a * k * 11) / 2; if (n == a * k * 11 + b * k + c * 2) ans[++ tot] = a * 10 * k + b * k + c; &#125; b --; if ((a + b) != 0 &amp;&amp; b &gt;= 0) &#123; //进位 c = (n - b * k - a * k * 11) / 2; if (n == a * k * 11 + b * k + c * 2) ans[++ tot] = a * 10 * k + b * k + c; &#125; &#125; sort(ans + 1, ans + 1 + tot); tot = unique(ans + 1, ans + 1 + tot) - ans - 1; if (!tot) printf("No solution."); else for (int i = 1; i &lt;= tot; ++ i) &#123; printf("%d", ans[i]); //不要问我为什么那么麻烦，不然会PE if (i &lt; tot) putchar(' '); &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>hdu</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hdu4334]Trouble]]></title>
    <url>%2F2019%2F02%2F17%2F%5Bhdu4334%5DTrouble%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：给定5个集合，从每个集合中选一个数，使得5个数的和为0. 输入格式：第一行：一个整数t表示数据组数。接下来t组数据，每组数据第一行一个整数表示集合的大小。接下来5行，每行n个数表示集合中的i元素。 输出格式：对于每组数据，输出Yes或No表示是否可以使数的和为0. 输入样例：221 -11 -11 -11 -11 -131 2 3-1 -2 -34 5 6-1 3 2-4 -10 -1 输出样例：NoYes 解析：一看到题目，n^5进行枚举肯定不可取。&emsp;&emsp;&emsp;那么先n^2预处理前2个集合数的和，经行hash，后n^3枚举后三行，在hash表中查。&emsp;&emsp;&emsp;似乎可行，于是便开打。&emsp;&emsp;&emsp;一提交，TLE了。&emsp;&emsp;&emsp;进行一波卡常，还是TLE了。&emsp;&emsp;&emsp;那么这么做不可行吗？可行！网上也有许多大佬用这方法A了此题。可能是本蒟蒻太弱，常数太大…&emsp;&emsp;&emsp;这里介绍用two pointers做的做法。&emsp;&emsp;&emsp;首先把前两个集合中的数两两相加，再将第3与4个集合中的数两两相加，得到两个数组。&emsp;&emsp;&emsp;将两个数组都从小到大sort一次。&emsp;&emsp;&emsp;枚举第5个集合中的数，对于集合中的每个数，创建l，r两个指针，分别指向两个数组其中一个的头与另一个的尾。&emsp;&emsp;&emsp;若三个数相加&gt;0，则将尾的指针向左移一位。&emsp;&emsp;&emsp;若&lt;0，则将头的指针向右移一位。&emsp;&emsp;&emsp;若=0则输出Yes，直接退出。&emsp;&emsp;&emsp;若不能得出0，则输出No。&emsp;&emsp;&emsp;一个比较巧妙的做法，无法理解的话可以画个图自行理解理解。&emsp;&emsp;&emsp;时间复杂度O(n^3)。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define ll long long#define rint register int using namespace std;const int maxn = 205;int t, n, tot;ll a[6][maxn], b[maxn * maxn], c[maxn * maxn];ll read(void) &#123; char c; while (c = getchar(), (c &lt; '0' || c &gt; '9') &amp;&amp; c != '-'); ll x = 0, y = 1; if (c == '-') y = -1; else x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x * y; &#125;int main() &#123; t = read(); rint i, j; while (t --) &#123; n = read(); for (i = 1; i &lt;= 5; ++ i) for (j = 1; j &lt;= n; ++ j) a[i][j] = read(); tot = 0; for (i = 1; i &lt;= n; ++ i) //构建第一个数组 for (j = 1; j &lt;= n; ++ j) b[++ tot] = a[1][i] + a[2][j]; tot = 0; for (i = 1; i &lt;= n; ++ i) //构建第二个数组 for (j = 1; j &lt;= n; ++ j) c[++ tot] = a[3][i] + a[4][j]; sort(b + 1, b + 1 + n * n); //排序 sort(c + 1, c + 1 + n * n); int flag = 0; for (i = 1; i &lt;= n; ++ i) &#123; int l = 1, r = n * n; if (flag) break; for (j = 1; j &lt;= n * n * 2; ++ j) &#123; //一共要进行n*n*2次移动 ll val = a[5][i] + b[l] + c[r]; if (val == 0) &#123; flag = 1; break; &#125; else if (val &gt; 0) r --; else l ++; &#125; &#125; if (flag) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>two pointers</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于本博客]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我又滚回来写博客了，虽说之前也写过一些，但好像大多都被我用来存代码了，真正认真写的数量不多。可现在搭好了自己的博客，便也不会那么随便了。说到搭博客，这也花了我好几个小时的时间，一大堆的东西以及不断的报错，搞的我心态爆炸（不过好在坚持过来了QAQ）。 关于之前写的博客，我会将上面比较有用的转移过来。而之前写博客的网站，随缘更新吧~ 不管怎样，写博客也是为了记录下自己学习中的经验与知识，以及将自己的博客向他人装装逼自己的学习经历与别人一起分享。在接下来的博客创作中，我会将自己解题时的所思所想一同写下，记录下自己的解题思路，好让内容利于理解。在总结算法或数据结构时，我也会将自己的思考写进博客中，与大家一同分享。同时也是为了让别人可以更加深刻地理解一个知识点。 总之，希望我的博客可以帮助到更多的人。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
</search>
