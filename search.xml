<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[CF1118C]Palindromic Matrix]]></title>
    <url>%2F2019%2F03%2F02%2F%5BCF1118C%5DPalindromic%20Matrix%2F</url>
    <content type="text"><![CDATA[题目描述：给定$n \times n$个数，要求构造一个$n \times n$的矩阵，使得这个矩阵是个回文矩阵。 输入格式：第一行一个数n。第二行$n \times n$个数表示给定的数。 输出格式：输出一个回文矩阵，输出”YES”，并输出一种即可。若无法构成回文矩阵，则输出”NO”。 输入样例：41 8 8 1 2 2 2 2 2 2 2 2 1 8 8 1输出样例：YES1 2 2 18 2 2 88 2 2 81 2 2 1 解析：题目不难？&emsp;&emsp;&emsp;看了看题面，发现若要成为回文的，那么每一个位置填数的个数只能为1或2或4。&emsp;&emsp;&emsp;那么找出每个所需个数相同的位置一起处理，每次看能否填上即可。&emsp;&emsp;&emsp;似乎没有什么好讲的，看到代码就懂了。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;vector&gt;#define pa pair &lt;int, int&gt;#define fir first#define sec second#define mp make_pairusing namespace std;const int maxn = 25;int n, ans[maxn][maxn], bt[1005];vector &lt;pa&gt; ve[5];int read(void) &#123; char c; while (c = getchar(), c &lt; '0' || c &gt; '9'); int x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n * n; ++ i) &#123; int x = read(); bt[x] ++; //记录每个数的个数 &#125; for (int i = 1; i &lt;= (n + 1) &gt;&gt; 1; ++ i) for (int j = 1; j &lt;= (n + 1) &gt;&gt; 1; ++ j) &#123; //统计每种格子的个数 if (i != n - i + 1 &amp;&amp; j != n - j + 1) ve[3].push_back(mp(i, j)); else if ((i != n - i + 1) ^ (j != n - j + 1)) ve[2].push_back(mp(i, j)); else ve[1].push_back(mp(i, j)); &#125; for (int i = 3; i ; -- i) //构造矩阵 for (int j = 0; j &lt; ve[i].size(); ++ j) &#123; int x = ve[i][j].fir, y = ve[i][j].sec; int poi = 1, cur = (i == 3) ? 4 : i; while (poi &lt; 1001 &amp;&amp; bt[poi] &lt; cur) poi ++; if (poi == 1001) return printf("NO"), 0; ans[x][y] = ans[n - x + 1][y] = ans[x][n - y + 1] = ans[n - x + 1][n - y + 1] = poi; bt[poi] -= cur; &#125; puts("YES"); for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= n; ++ j) printf("%d ", ans[i][j]); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI生存手册——splay]]></title>
    <url>%2F2019%2F02%2F19%2FOI%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C%E2%80%94%E2%80%94splay%2F</url>
    <content type="text"><![CDATA[splay是一种非常好用的数据结构，功能十分强大，被称为序列之王。我之前写过一篇关于treap的博客，粗略地介绍了一下treap，如果有空我还会再写一遍（对，如果有空）。splay在操作上比treap更加巧妙，但在理解上似乎稍有难度（其实也不难）。两者都是二叉排序树的升级版，只不过treap是用随机的优先值来维护平衡，splay则是通过旋转来维护。 一、前置知识1234567size[x]:x的子树大小fa[x]:x的父亲节点ch[x][0/1]:x的左儿子和右儿子cnt[x]:权值为x的数出现的次数val[x]:节点标号为x的点的权值rt:树的根tot:树的节点总数 还有一些简单的函数。1234567void up(int x) &#123; //维护节点的size值 size[x] = cnt[x] + size[ch[x][0]] + size[ch[x][1]];&#125;int chk(int x) &#123; //询问该节点是它父亲的左儿子还是右儿子 return ch[fa[x]][1] == x;&#125; 二、旋转操作看下面的一张图。若要将节点4旋转到节点2的位置，图会变成这样：显然，旋转后的树也满足二叉排序树的性质。这样，代码就打出来了：1234567void rotate(int x) &#123; int y = fa[x], z = fa[y], k = chk(x), w = ch[x][k ^ 1]; ch[y][k] = w; fa[w] = y; ch[z][chk(y)] = x; fa[x] = z; ch[x][k ^ 1] = y; fa[y] = x; up(y); up(x);&#125; 如果无法理解可以自己画图比划比划，注意coding过程中不要出现打错或遗漏。如果你掌握了旋转的相关知识，那么恭喜你，splay中最难的部分已经你已经会了。 三、伸展操作说白了就是将一个节点旋转到指定父亲的儿子。不过要注意在祖父，父亲，儿子三点一线时，要先旋父亲，再旋儿子。这么做似乎是为了使树平衡，保持树的深度。1234567891011void splay(int x, int t) &#123; while (fa[x] != t) &#123; int y = fa[x], z = fa[y]; if (z != t) &#123; if (chk(x) == chk(y)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!t) rt = x;&#125; 四、查找操作这是一个辅助操作，可以在后面帮我们解决其他问题。作用便是将最大的小于等于x的数所在的节点splay到根。123456void find(int x) &#123; if (!rt) return; int cur = rt; while (ch[cur][x &gt; val[cur]] &amp;&amp; val[cur] != x) cur = ch[cur][x &gt; val[cur]]; splay(cur, 0);&#125; 五、插入操作将一个数插入树中。从根节点往下找，小于该节点的值就向左儿子走，大于该节点的值就向右儿子走。若值与节点的值相等，就将cnt+1。注意最后要将节点splay到根，以保持树平衡。12345678910111213141516void insert(int x) &#123; int cur = rt, id = 0; while (cur &gt; 0 &amp;&amp; val[cur] != x) &#123; id = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur &gt; 0) cnt[cur] ++; else &#123; cur = ++ tot; if (id) ch[id][x &gt; val[id]] = cur; ch[cur][0] = ch[cur][1] = 0; val[cur] = x; fa[cur] = id; size[cur] = cnt[cur] = 1; &#125; splay(cur, 0);&#125; 六、查询第k大找到树中第k大的数。也是从根节点往下找，由于左节点必定小于右节点，所以可以判断在哪颗子树进行查找。1234567891011int kth(int x) &#123; int cur = rt; while (1) &#123; if (x &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else if (x &gt; size[ch[cur][0]] + cnt[cur]) &#123; x -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else return cur; &#125;&#125; 七、查询排名为x的数这个就比较简单，先调用find，那么排名就是左子树的大小+1。但一般都要先往splay中插入一个-inf来防止爆炸，所以排名便不用+1，即为左子树大小。1234int rank(int x) &#123; find(x); return size[ch[rt][0]];&#125; 八、查找x的前驱先调用一次find，那么要么前驱是根，要么就在左子树最深的右子树。1234567int pre(int x) &#123; find(x); if (x &gt; val[rt]) return rt; int cur = ch[rt][0]; while (ch[cur][1] &gt; 0) cur = ch[cur][1]; return cur;&#125; 九、查找x的后继这也要先调用一次find，但这里要注意，虽然find找到的数是小于等于x的，可如果树上所有的点都大于x，那么find就会失效。所以在找后继时也要判断根是否就是后继。其他的都和找前驱时差不多。1234567int succ(int x) &#123; find(x); if (x &lt; val[rt]) return rt; int cur = ch[rt][1]; while (ch[cur][0] &gt; 0) cur = ch[cur][0]; return cur;&#125; 十、删除值为x的节点这就有点意思了。先将x的前驱splay到根，再将x的后继splay到根的右儿子，那么后继的左儿子就是要删的点。为什么呢？因为一个点有且仅有一个前驱和后继，所以只要确定了前驱与后继，那么这个点就是唯一的。注意如果cnt&gt;1则将cnt-1，且不要忘了将点选到根。123456789void del(int x) &#123; int pr = pre(x), su = succ(x); splay(pr, 0); splay(su, rt); if (cnt[ch[su][0]] &gt; 1) &#123; cnt[ch[su][0]] --; splay(ch[su][0], 0); &#125; else ch[su][0] = 0; &#125; 至此splay所有的基本操作都讲完了，大家可以找一些模板或题目练练手。注意要先插入一个-inf与inf，防止爆炸。模板题代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;using namespace std;const int maxn = 1e5 + 5;int n, size[maxn], ch[maxn][2], val[maxn], cnt[maxn], fa[maxn], rt, tot;int read(void) &#123; char c; while (c = getchar(), (c &lt; '0' || c &gt; '9') &amp;&amp; c != '-'); int x = 0, y = 1; if (c == '-') y = -1; else x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x * y; &#125;void up(int x) &#123; size[x] = cnt[x] + size[ch[x][0]] + size[ch[x][1]];&#125;int chk(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; int y = fa[x], z = fa[y], k = chk(x), w = ch[x][k ^ 1]; ch[y][k] = w; fa[w] = y; ch[z][chk(y)] = x; fa[x] = z; ch[x][k ^ 1] = y; fa[y] = x; up(y); up(x);&#125;void splay(int x, int t) &#123; while (fa[x] != t) &#123; int y = fa[x], z = fa[y]; if (z != t) &#123; if (chk(x) == chk(y)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!t) rt = x;&#125;void find(int x) &#123; if (!rt) return; int cur = rt; while (ch[cur][x &gt; val[cur]] &amp;&amp; val[cur] != x) cur = ch[cur][x &gt; val[cur]]; splay(cur, 0);&#125;void insert(int x) &#123; int cur = rt, id = 0; while (cur &gt; 0 &amp;&amp; val[cur] != x) &#123; id = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur &gt; 0) cnt[cur] ++; else &#123; cur = ++ tot; if (id) ch[id][x &gt; val[id]] = cur; ch[cur][0] = ch[cur][1] = 0; val[cur] = x; fa[cur] = id; size[cur] = cnt[cur] = 1; &#125; splay(cur, 0);&#125;int kth(int x) &#123; int cur = rt; while (1) &#123; if (x &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else if (x &gt; size[ch[cur][0]] + cnt[cur]) &#123; x -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else return cur; &#125;&#125;int rank(int x) &#123; find(x); return size[ch[rt][0]];&#125;int pre(int x) &#123; find(x); if (x &gt; val[rt]) return rt; int cur = ch[rt][0]; while (ch[cur][1] &gt; 0) cur = ch[cur][1]; return cur;&#125;int succ(int x) &#123; find(x); if (x &lt; val[rt]) return rt; int cur = ch[rt][1]; while (ch[cur][0] &gt; 0) cur = ch[cur][0]; return cur;&#125;void del(int x) &#123; int pr = pre(x), su = succ(x); splay(pr, 0); splay(su, rt); if (cnt[ch[su][0]] &gt; 1) &#123; cnt[ch[su][0]] --; splay(ch[su][0], 0); &#125; else ch[su][0] = 0; &#125;int main() &#123; n = read(); insert(2e9); insert(-2e9); while (n --) &#123; int opt = read(), x = read(); if (opt == 1) insert(x); else if (opt == 2) del(x); else if (opt == 3) printf("%d\n", rank(x)); else if (opt == 4) printf("%d\n", val[kth(x + 1)]); else if (opt == 5) printf("%d\n", val[pre(x)]); else if (opt == 6) printf("%d\n", val[succ(x)]); &#125; return 0;&#125; 十一、区间翻转你以为讲完了？其实并没有！splay被称为序列之王的原因便是它可以想线段树一样打标记，以进行区间上的修改。这里就看一道经典的例题：例题首先明确要维护的对象，即序列中每个数的位置（这题中其实就是权值）。而题目中第i个位置的数，可以发现就是树中第k大的数。于是找第i位置上的数就转化成了求第i大的数。于是可以把l-1位置的数旋到根，r+1位置的数旋到根的右儿子，那么右儿子的左子树就是l~r中的数。翻转只要在节点上打上标记，遇上标记时翻转左右子树即可。下放标记和线段树类似，这里就不多说了。注意若翻转起点从1开始，那么-1后就成了0。为了防止0的出现，可以将每个位置的标号都向后移一位，即1位置对应了2，2位置对应了3…，n位置对应了n+1。具体如何实现就是在刚开始时加入一个-inf。最后输出答案时按中序遍历输出即可。注意一下细节就应该没问题。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5 + 5;int n, m, bj[maxn];int size[maxn], cnt[maxn], val[maxn], fa[maxn], ch[maxn][2], rt, tot;int read(void) &#123; char c; while (c = getchar(), c &lt; '0' || c &gt; '9'); int x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x;&#125;void up(int x) &#123; size[x] = cnt[x] + size[ch[x][0]] + size[ch[x][1]];&#125;int chk(int x) &#123; return ch[fa[x]][1] == x;&#125;void rotate(int x) &#123; int y = fa[x], z = fa[y], k = chk(x), w = ch[x][k ^ 1]; ch[x][k ^ 1] = y; ch[y][k] = w; ch[z][chk(y)] = x; fa[y] = x; fa[x] = z; fa[w] = y; up(y); up(x);&#125;void splay(int x, int t) &#123; while (fa[x] != t) &#123; int y = fa[x], z = fa[y]; if (z != t) &#123; if (chk(y) == chk(x)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!t) rt = x;&#125;void insert(int x) &#123; int cur = rt, id = 0; while (cur &gt; 0 &amp;&amp; val[cur] != x) &#123; id = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur &gt; 0) cnt[cur] ++; else &#123; cur = ++ tot; if (id) ch[id][x &gt; val[id]] = cur; val[cur] = x; fa[cur] = id; ch[cur][0] = ch[cur][1] = 0; cnt[cur] = size[cur] = 1; &#125; splay(cur, 0);&#125;void pushdown(int x) &#123; if (!bj[x]) return; swap(ch[x][0], ch[x][1]); bj[ch[x][0]] ^= 1; bj[ch[x][1]] ^= 1; bj[x] = 0;&#125;int kth(int x) &#123; int cur = rt; while (1) &#123; pushdown(cur); //注意这里也要pushdown if (x &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else if (x &gt; size[ch[cur][0]] + cnt[cur]) &#123; x -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else return cur; &#125;&#125;void reverse(int x, int y) &#123; x = kth(x); y = kth(y + 2); //由于向右移了一格，所以x-1变为了x，y+1变为了y+2 splay(x, 0); splay(y, x); bj[ch[y][0]] ^= 1;&#125;void write(int x) &#123; pushdown(x); if (ch[x][0] &gt; 0) write(ch[x][0]); if (val[x] &gt; 0 &amp;&amp; val[x] &lt;= n) printf("%d ", val[x]); if (ch[x][1] &gt; 0) write(ch[x][1]);&#125;int main() &#123; n = read(); m = read(); insert(-2e9); insert(2e9); for (int i = 1; i &lt;= n + 1; ++ i) insert(i); //这里要到n+1 while (m --) &#123; int x = read(), y = read(); reverse(x, y); &#125; write(rt); return 0;&#125; 至此，关于splay的操作就结束了，希望大家可以多多练习，以熟练掌握这一数据结构。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI生存手册</tag>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI生存手册——序言]]></title>
    <url>%2F2019%2F02%2F18%2FOI%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8C%E2%80%94%E2%80%94%E5%BA%8F%E8%A8%80%2F</url>
    <content type="text"><![CDATA[为什么要开这么一块呢？其实就是为自己总结算法与数据结构找了一个好听的标题。 此块包含的内容可能会比较杂，各种知识可能都会包括，更新的顺序也不按难度来，各位看看就好。 这些算法中包含了我的理解，如有不对的地方请多多包涵，谢谢。 不管怎样，我会尽我的全力把知识点向大家将清楚，也希望大家能够在我的博客中学到更多的东西。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI生存手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职业体验半日游]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%81%8C%E4%B8%9A%E4%BD%93%E9%AA%8C%E5%8D%8A%E6%97%A5%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[感觉博客好像被我用成了日记… 在寒假的末尾，突然发现自己还有一个职业体验的作业没做，便赶忙联系了我爸的一位同学———某派出所教导员，开始了我的职业体验。 本以为大家都是明白人，盖个章签个字写个评语就好了，可没想到竟是如此正式。没办法，我也只得认命。 上午便跟着一位警察出去处警，本以为是多么好玩，结果就只是处理了些民事纠纷。不过同时我也开拓了自己的视野——原来还有那么奇葩的案子！ 一上来一个神奇的案子：一个人车停在别人家门口，车被别人用粪泼了。 办案时我也在一旁看到了警察的严谨：不被人情干扰，依法办案。 在办案时也有一些比较值得人思考的问题，我这里就不赘述了（主要是因为我太懒了，不想写）。 第二个案子便十分无聊：一个人卖橘子提前谈好了价钱，还收了定金，结果在卖时嫌太便宜，想抬高价格。 说实话，真没想到这么鸡毛蒜皮的小事也要用到警察。到了那后，一屋子挤满了人，七嘴八舌，互相交谈，很是热(吵)闹。屋子中似乎大多都是来看热闹的人，但这也不奇怪，这不就是吃瓜群众吗，谁不是呢？ 互相聊了老半天，终于解决了问题。可是，已经付了定金的事，为什么还要报案呢？ 在派出所吃了午饭，便在办公室和带我的警察闲谈。（不得不说，派出所的伙食确实挺不错）。 在闲谈中，我知道了许多，也明白了许多。我了解了走入社会后的压力，得知了难以对抗的现实，也知道了学习很重要，可似乎又不是最重要的。 “我觉得，人生就是一棵树。如果你主干不断往上长，风一吹就断了。可你如果长出了枝叶，有那么容易被吹断吗？” 不仅仅是人生的哲理，还有许多关于警察这个岗位的事。 是的，从小到大，警察在我们的心中都是那么神圣。警察叔叔这个字眼，下至三岁小孩，上至八十老太都热情地称呼。 可是，殊不知，在警察这个词的背后，隐藏着多少深意。警察换来的，是安全，而这安全，却是由没日没夜的加班加点换来的。 “请问您对自己的工作愿景是什么？” “能够正常上班，正常下班，正常休假，能够有时间陪陪老婆孩子，能够有时间和老婆出去度假。” “这么普通，您就没什么梦想吗？” “梦想？在你这么大的时候还是有的。可现在，我连这普通的想法都没法实现。”原来，这就是警察。警察，真的不好当。办案稍不满意会被投诉，案子没破出来会被投诉，说话不准确会被投诉。这就是警察。“警察也是人，上有老下有小，我也要养家糊口。”“你办案受伤了，你自己没什么关系，你的父母怎么想，他们辛辛苦苦将你带大，为什么当警察就非得受伤？”“警察的工作是围城，里面的人要出去，外面的人要进来。”通过这次的职业体验，我似乎明白了许多，也成长了许多。是啊，人生的路还长，一切都要自己来走。在此感谢教导我的孙皆权警察。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hdu1271]整数对]]></title>
    <url>%2F2019%2F02%2F17%2F%5Bhdu1271%5D%E6%95%B4%E6%95%B0%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：Gardon和小希玩了一个游戏，Gardon随便想了一个数A（首位不能为0），把它去掉一个数字以后得到另外一个数B，他把A和B的和N告诉了小希，让小希猜想他原来想的数字。不过为了公平起见，如果小希回答的数虽然不是A，但同样能达到那个条件（去掉其中的一个数字得到B，A和B之和是N），一样算小希胜利。而且小希如果能答出多个符合条件的数字，就可以得到额外的糖果。所以现在小希希望你编写一个程序，来帮助她找到尽可能多的解。例如，Gardon想的是A=31,B=3 告诉小希N=34，小希除了回答31以外还可以回答27（27+7=34）所以小希可以因此而得到一个额外的糖果。 输入描述：输入包含多组数据，每组数据一行，包含一个数N(1&lt;=N&lt;=10^9)，文件以0结尾。输出描述：对于每个输入的N，输出所有符合要求的解（按照大小顺序排列）如果没有这样的解，输出”No solution.” 输入样例：34152210 输出样例：27 31 32126 136 139 141No solution. 解析：一看到题目没有一点想法，结果对着题目瞪了大半天…&emsp;&emsp;&emsp;听了老师讲解后便恍然大悟，原来还有这么巧妙的做法。&emsp;&emsp;&emsp;设原来的数为abc，b是删除的那个数，a是删去的数之前的所有数，c是删去的数之后的所有数。&emsp;&emsp;&emsp;比如原来的数是1341，若要删去4，则a=13，b=4，c=1。&emsp;&emsp;&emsp;于是我们可以枚举b所在的数位，假设b所在k位，那么&emsp;&emsp;&emsp;原数=$a\times10^{k+1}+b*10^{k}+c$&emsp;&emsp;&emsp;删去后=$a\times10^{k}+c$&emsp;&emsp;&emsp;两数相加，即n=$(11a+b)\times10^{k}+2c$&emsp;&emsp;&emsp;如此一来就可算出a、b、c的值。&emsp;&emsp;&emsp;这里注意a与b不能两个都为0，且要注意2c的进位问题。&emsp;&emsp;&emsp;其实进位只要关心b-1后是否会小于0即可。&emsp;&emsp;&emsp;于是我们高高兴兴地打完了代码，提交后却发现，WA了。&emsp;&emsp;&emsp;为什么呢？看看其他各位大佬的代码，原来这么计算下来会出现重复，比如5002在计算时会将十位与百位上的0各自去掉，所以要判重。 代码如下：12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n, tot, ans[10001];int a, b, c;int main() &#123; while (scanf("%d", &amp;n), n &gt; 0) &#123; tot = 0; for (int k = 1; k &lt;= n; k *= 10) &#123; a = n / k / 11; b = n / k % 11; if ((a + b) != 0 &amp;&amp; b &lt; 10) &#123; //不进位 c = (n - b * k - a * k * 11) / 2; if (n == a * k * 11 + b * k + c * 2) ans[++ tot] = a * 10 * k + b * k + c; &#125; b --; if ((a + b) != 0 &amp;&amp; b &gt;= 0) &#123; //进位 c = (n - b * k - a * k * 11) / 2; if (n == a * k * 11 + b * k + c * 2) ans[++ tot] = a * 10 * k + b * k + c; &#125; &#125; sort(ans + 1, ans + 1 + tot); tot = unique(ans + 1, ans + 1 + tot) - ans - 1; if (!tot) printf("No solution."); else for (int i = 1; i &lt;= tot; ++ i) &#123; printf("%d", ans[i]); //不要问我为什么那么麻烦，不然会PE if (i &lt; tot) putchar(' '); &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>hdu</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hdu4334]Trouble]]></title>
    <url>%2F2019%2F02%2F17%2F%5Bhdu4334%5DTrouble%2F</url>
    <content type="text"><![CDATA[原题链接 题目描述：给定5个集合，从每个集合中选一个数，使得5个数的和为0. 输入格式：第一行：一个整数t表示数据组数。接下来t组数据，每组数据第一行一个整数表示集合的大小。接下来5行，每行n个数表示集合中的i元素。 输出格式：对于每组数据，输出Yes或No表示是否可以使数的和为0. 输入样例：221 -11 -11 -11 -11 -131 2 3-1 -2 -34 5 6-1 3 2-4 -10 -1 输出样例：NoYes 解析：一看到题目，n^5进行枚举肯定不可取。&emsp;&emsp;&emsp;那么先n^2预处理前2个集合数的和，经行hash，后n^3枚举后三行，在hash表中查。&emsp;&emsp;&emsp;似乎可行，于是便开打。&emsp;&emsp;&emsp;一提交，TLE了。&emsp;&emsp;&emsp;进行一波卡常，还是TLE了。&emsp;&emsp;&emsp;那么这么做不可行吗？可行！网上也有许多大佬用这方法A了此题。可能是本蒟蒻太弱，常数太大…&emsp;&emsp;&emsp;这里介绍用two pointers做的做法。&emsp;&emsp;&emsp;首先把前两个集合中的数两两相加，再将第3与4个集合中的数两两相加，得到两个数组。&emsp;&emsp;&emsp;将两个数组都从小到大sort一次。&emsp;&emsp;&emsp;枚举第5个集合中的数，对于集合中的每个数，创建l，r两个指针，分别指向两个数组其中一个的头与另一个的尾。&emsp;&emsp;&emsp;若三个数相加&gt;0，则将尾的指针向左移一位。&emsp;&emsp;&emsp;若&lt;0，则将头的指针向右移一位。&emsp;&emsp;&emsp;若=0则输出Yes，直接退出。&emsp;&emsp;&emsp;若不能得出0，则输出No。&emsp;&emsp;&emsp;一个比较巧妙的做法，无法理解的话可以画个图自行理解理解。&emsp;&emsp;&emsp;时间复杂度O(n^3)。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define ll long long#define rint register int using namespace std;const int maxn = 205;int t, n, tot;ll a[6][maxn], b[maxn * maxn], c[maxn * maxn];ll read(void) &#123; char c; while (c = getchar(), (c &lt; '0' || c &gt; '9') &amp;&amp; c != '-'); ll x = 0, y = 1; if (c == '-') y = -1; else x = c - '0'; while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; return x * y; &#125;int main() &#123; t = read(); rint i, j; while (t --) &#123; n = read(); for (i = 1; i &lt;= 5; ++ i) for (j = 1; j &lt;= n; ++ j) a[i][j] = read(); tot = 0; for (i = 1; i &lt;= n; ++ i) //构建第一个数组 for (j = 1; j &lt;= n; ++ j) b[++ tot] = a[1][i] + a[2][j]; tot = 0; for (i = 1; i &lt;= n; ++ i) //构建第二个数组 for (j = 1; j &lt;= n; ++ j) c[++ tot] = a[3][i] + a[4][j]; sort(b + 1, b + 1 + n * n); //排序 sort(c + 1, c + 1 + n * n); int flag = 0; for (i = 1; i &lt;= n; ++ i) &#123; int l = 1, r = n * n; if (flag) break; for (j = 1; j &lt;= n * n * 2; ++ j) &#123; //一共要进行n*n*2次移动 ll val = a[5][i] + b[l] + c[r]; if (val == 0) &#123; flag = 1; break; &#125; else if (val &gt; 0) r --; else l ++; &#125; &#125; if (flag) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>hdu</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于本博客]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我又滚回来写博客了，虽说之前也写过一些，但好像大多都被我用来存代码了，真正认真写的数量不多。可现在搭好了自己的博客，便也不会那么随便了。说到搭博客，这也花了我好几个小时的时间，一大堆的东西以及不断的报错，搞的我心态爆炸（不过好在坚持过来了QAQ）。 关于之前写的博客，我会将上面比较有用的转移过来。而之前写博客的网站，随缘更新吧~ 不管怎样，写博客也是为了记录下自己学习中的经验与知识，以及将自己的博客向他人装装逼自己的学习经历与别人一起分享。在接下来的博客创作中，我会将自己解题时的所思所想一同写下，记录下自己的解题思路，好让内容利于理解。在总结算法或数据结构时，我也会将自己的思考写进博客中，与大家一同分享。同时也是为了让别人可以更加深刻地理解一个知识点。 总之，希望我的博客可以帮助到更多的人。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
</search>
